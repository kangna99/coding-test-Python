"""
4번 문제의 시간복잡도를 줄인 코드입니다.
"""

n, k = map(int, input().split())
ans = 0

while True:
    if n < k:
        break
    target = (n // k) * k
    ans += (n - target)  # 나누는 연산 전 먼저 1씩 빼야하는 횟수를 ans에 저장
    n = target  # n값을 target과 같게 만들어 이제부터는 나누는 연산만 해도 됨

    while n % k == 0:
        n //= k
        ans += 1

ans += (n - 1)  # 마지막 n을 더 이상 k로 나눌 수 없을 때 1이 될 때까지 빼는 연산 수행
print(ans)

# 문제 분석
# 1. 가능하면 최대한 많이 나누는(나눌 수 있다면 나누는) 작업이 왜 최적의 해를 항상 보장하는가?
# K가 2 이상이기만 하면, K로 나누는 것이 1을 빼는 것보다 항상 빠르게 N을 줄일 수 있으며,
# N은 항상 1에 도달하게 된다.
#
# 2. target 변수를 쓰는 이유는 반복문 한번에 나누는 연산을 바로 수행하기 위한 것으로 반복 횟수에 따라
# 기하급수적으로 변하는 시간복잡도를 줄이기 위한 테크닉(log시간)
